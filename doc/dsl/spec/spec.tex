\documentclass[12pt]{article}

\usepackage{bcprules, proof}
\usepackage{xspace}
\usepackage{amsmath}

\newcommand{\dsl}{Neve\xspace}
\newcommand\bnf{\,\,|\,\,}
\newcommand\SB[1]{\llbracket#1\rrbracket}
\newcommand\stepsone{\longrightarrow}
\renewcommand\c[1]{\text{#1}}

\begin{document}
\title{The Specification of Lingua\\
  \large{A DSL for writing Scala compiler extensions}}
\author{Amanj Sherwany}
  
  
  
\maketitle
\section{Keywords}

\dsl defines the following keywords: \textbf{package, import, plugin, phase,
runsAfter, runsRightAfter, runsBefore, transform, check, if, else, match,
case, def, tree, private}


\section{The Context-Free Grammar (CFG) of \dsl}
% ~\c{\overline{Import}}~\c{Plugin$($\overline{Phase}$)$} \\
\begin{align*}
  \textbf{Program} & ::= \c{(Package $\bnf \epsilon$)}~\c{$\overline{Import}$}~
      \c{Plugin`('$\overline{ID}$`)'}~\c{$\overline{Phase}$}\\
  \textbf{Package} & ::= \c{package Select} \\
  \textbf{Import} & ::= \c{import Select (.$\_ \bnf \epsilon$)} \\
  \textbf{Plugin} & ::= \c{plugin ID (\{ $\overline{Def}~\} \bnf \epsilon$ )} \\
  \textbf{Phase} & ::= \c{phase ID`('String`)' 
    \{ Preambles (Transform $\bnf$ Check)~$\overline{Def}$ \}} \\
  \textbf{Preambles} & ::= \c{After Before} \\
  \textbf{After} & ::= \c{(runsAfter $\bnf$ runsRightAfter) = String} \\
  \textbf{Before} & ::= \c{runsBefore = String} \\
  \textbf{Transform} & ::= \c{transform Block} \\
  \textbf{Check} & ::= \c{check Blcok} \\
  \textbf{Type} & ::= \c{Qual} \bnf \c{`('$\overline{Type}$`)'} \bnf 
    \c{Qual[$\overline{Qual}$]} \\
  \textbf{Expression} & ::= \c{Expression $\bnf$ ID$\bnf$ Select} \\
     & \bnf \c{ Match $\bnf$ IfElse $\bnf$ Fun $\bnf$ Apply $\bnf$ Literal} \\
     & \bnf \c{Unary $\bnf$ Binary $\bnf$ `('Expression`)'} \\
   \textbf{Def} & ::= \c{(private $\bnf \epsilon$) def (ID TParams Params $\bnf$
    `('$\overline{ID}$`)') : Type = Expression} \\
  \textbf{Statement} & ::= \c{Def $\bnf$ Expression} \\
  \textbf{Select} & ::= \c{Expression.Expression} \\
  \textbf{Qual} & ::= \c{Expression.ID} \bnf (\c{Select.} \bnf 
     \epsilon)~\c{ID} \bnf \c{Expression} \\
  \textbf{Match} & ::= \c{Expression match \{ $\overline{Case}$ \}} \\
  \textbf{Case} & ::= \c{WRITE IT} \\
  \textbf{IfElse} & ::= \c{if`('Epxression`)' Expression else Expression} \\
  \textbf{Fun} & ::= \c{`('Params`)' $=>$ Expression} \\
  \textbf{Apply} & ::= \c{(ID $\bnf$ Select) `('$\overline{Expression}$`)'} \\
  \textbf{Unary} & ::= \c{Uop Expression} \\
  \textbf{Binary} & ::= \c{Expression Bop Expression} \\
  \textbf{Block} & ::= \c{\{ $\overline{Statment}$ Expression \}} \\
  \textbf{Params} & ::= \c{ID: Type} \\
  \textbf{TParams} & ::= [\overline{\c{ID}~(<: \bnf :>)~\c{ID}}] \\
  \textbf{Bop} & ::= - \bnf + \bnf * \bnf / \bnf < \bnf <= \bnf > \bnf => \\
      & \bnf \% \bnf == \bnf \&\& \bnf \texttt{||} \bnf != \\
  \textbf{Uop} & ::= - \bnf ! \\
  \textbf{ID} & ::= [a-zA-Z\_]\overline{[0-9a-zA-Z\_]}
\end{align*}




%
%
% Params := ID: ID
%
% Generics := [(ID ((<: | :>) ID))*]



% Op := - | + | * | / | < | <= | > | => | % | == | && | || | != | !

\end{document}
