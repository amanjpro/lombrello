\documentclass[12pt]{article}

\usepackage{bcprules, proof}
\usepackage{xspace}
\usepackage{amsmath}

\newcommand{\dsl}{Neve\xspace}
\newcommand\bnf{\,\,|\,\,}
\newcommand\SB[1]{\llbracket#1\rrbracket}
\newcommand\stepsone{\longrightarrow}
\renewcommand\c[1]{\text{#1}}

\begin{document}
\title{The Specification of \dsl\\
  \large{A DSL for writing Scala compiler extensions}}
\author{Amanj Sherwany}
  
  
  
\maketitle
\section{Keywords}

\raggedright
\dsl defines the following keywords: \textbf{runsAfter, runsRightAfter, runsBefore,
  import, if, else, match, package, plugin, phase, transform, check, def, case,
  tree, super, this, try, catch, finally, throw, new, true, false}

\section{Reserved Words}

All Scala keywords are reserved words here, but not all of them are used. The
following lists all the reserved words that cannot be used in \dsl:
\textbf{abstract, class, do, extends, for, forSome, implicitly, lazy, null,
  object, private, override, protected, return, sealed, trait, try, type, val,
  var, while, with, yield}


\section{Operators}
\dsl defines the following operators:

\begin{itemize}
  \item Binary operators: $+,~-,~*,~/,~\%,~|~|,~\&~\&,~
    <,~>,~>=,~<=,~!=,~==,~<<,~::,~++,~->,~>:,~<:$
  \item Unary operators: \textbf{-, +, !}
\end{itemize}
  

\newpage

\section{The Context-Free Grammar (CFG) of \dsl}
% ~\c{\overline{Import}}~\c{Plugin$($\overline{Phase}$)$} \\
\begin{align*}
  \textbf{Program} & ::= \overline{\c{(Package $\bnf \epsilon$)}~
    \c{$\overline{Import}$}~\c{Plugin}~\c{$\overline{Phase}$}}\\
  \textbf{Package} & ::= \c{package Qual} \\
  \textbf{Import} & ::= \c{import Qual (.$\_ \bnf \epsilon$)} \\
  \textbf{Plugin} & ::= \c{plugin ID($\overline{ID}$) (\{ $\overline{Def}~\} 
      \bnf \epsilon$ )} \\
  \textbf{Phase} & ::= \c{phase ID`('String`)' 
    \{ Preambles (Transform $\bnf$ Check)~$\overline{Def}$ \}} \\
  \textbf{Preambles} & ::= \c{After Before} \\
  \textbf{After} & ::= \c{(runsAfter $\bnf$ runsRightAfter) 
      `('$\overline{String}$`)';} \\
  \textbf{Before} & ::= \c{runsBefore `('$\overline{String}$`)';} \\
  \textbf{Transform} & ::= \c{transform = Expression} \\
  \textbf{Check} & ::= \c{check = Expression} \\
  \textbf{Expression} & ::= \c{`('$\overline{Expression}$`)' $\bnf$ 
          ID$\bnf$ Select} \bnf \c{New} \bnf \c{Throw} \\
     & \bnf \c{ Match $\bnf$ IfElse $\bnf$ Fun $\bnf$ Apply $\bnf$ Literal} \\
     & \bnf \c{Unary $\bnf$ Binary $\bnf$ Block $\bnf$ Try
       $\bnf$ `('Expression`)'} \\
  \textbf{Def} & ::= \c{def (ID TParams Params $\bnf$ `('$\overline{ID}$`)') :
    Type = Expression} \\
  \displaybreak
  \textbf{Statement} & ::= \c{Def $\bnf$ Expression;} \\
  \textbf{Select} & ::= \c{Expression.ID} \\
  \textbf{Type} & ::= \c{Qual} \bnf \c{`('$\overline{Type}$`)'} \bnf 
    \c{Qual[$\overline{Qual}$]} \bnf \c{`('$\overline{Type}$`)' $=>$ Type} \\
  \textbf{Qual} & ::= \c{Qual.ID} \bnf \c{ID} \\
  \textbf{Match} & ::= \c{Expression match \{ $\overline{Case}$ \}} \\
  \textbf{Try} & :: = \c{try Expression catch \{}~\overline{Case} \c{ \} }
      (\c{finally Expression} \bnf \epsilon) \\
  \textbf{Case} & ::= \c{case Patterns (if Expression $\bnf \epsilon$) $=>$
        BlockLike} \\
  \textbf{BlockLie} & ::= \c{$\overline{Statment}$ Expression; $\bnf$ Block} \\
  \textbf{Patterns} & ::= \c{Pattern Patterns2} \\
  \textbf{Patterns2} & ::= \c{`$|$' Pattern Patterns2} \bnf \epsilon \\
  \textbf{Pattern} & ::= \c{ID} \bnf \c{ID: Qual} \bnf \c{\_ : Qual} \bnf
        \c{\_} \bnf \c{ID @ Qual`('$\overline{Patterns}$`)'} \bnf \c{Lit} \\
  \textbf{IfElse} & ::= \c{if`('Epxression`)' Expression else Expression} \\
  \textbf{New} & ::= \c{new Type`('$\overline{Expression}$`)'} \\
  \textbf{Throw} & ::= \c{throw Expression} \\
  \textbf{Fun} & ::= \c{`('Params`)' $=>$ Expression} \\
  \textbf{Apply} & ::= \c{(ID $\bnf$ Select) ([$\overline{Type}$] 
        $\bnf$ $\epsilon$) `('$\overline{Expression}$`)'} \\
  \textbf{Unary} & ::= \c{Uop Expression} \\
  \textbf{Binary} & ::= \c{Expression Bop Expression} \\
  \textbf{Block} & ::= \c{\{ $\overline{Statment}$ Expression; \}} \\
  \textbf{Params} & ::= \c{ID: Type} \\
  \textbf{TParams} & ::= [\overline{\c{ID}~(<: \bnf >:)~\c{Type}}] \\
  \textbf{Bop} & ::= - \bnf + \bnf * \bnf / \bnf < \bnf <= \bnf > \bnf >= \\
      & \bnf \% \bnf == \bnf \&\& \bnf \texttt{||} \bnf != \\
      & \bnf :: \bnf ++ \bnf << \bnf >> \bnf -> \\
  \textbf{Uop} & ::= - \bnf ! \\
  \textbf{ID} & ::= [a-zA-Z\_]\overline{[0-9a-zA-Z\_]} \\
  \textbf{Lit} & ::= ``Language Literals''
\end{align*}



\end{document}
